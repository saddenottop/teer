-- visual.lua (полный, с Weapon ESP через PlayerTable.equippedItem.type и Object ESP)
-- Подключать так:
-- local Visual = loadstring(game:HttpGet("https://raw.githubusercontent.com/saddatopt/ts/main/visual.lua"))()
-- Visual(VisualTab)

return function(VisualTab)
    assert(VisualTab, "Передайте VisualTab при вызове visual.lua!")

    -- === НАСТРОЙКИ ===
    local espSettings = {
        enabled = false,
        box = false,
        boxtype = "Default",
        boxColor = Color3.new(1,1,1),
        name = false,
        nameColor = Color3.new(1,1,1),
        weapon = false,
        weaponColor = Color3.new(1,1,1),
        distance = false,
        distanceColor = Color3.new(1,1,1),
        maxDistance = 5000,
        sleepcheck = false,
        aicheck = false
    }
    local chamsSettings = {
        hand = false,
        handColor = Color3.new(1, 1, 1),
        handMat = "ForceField",
        item = false,
        itemColor = Color3.new(1, 1, 1),
        itemMat = "ForceField"
    }
    local traceSettings = {
        enabled = false,
        color = Color3.new(0,0.4,1),
        mode = "Legit"
    }
    local objectEspSettings = {
        droppeditem = false,
        corpse = false,
        atv = false
    }

    -- === UI ===
    local EspBox = VisualTab:AddLeftGroupbox("ESP", "box")
    local ChamsBox = VisualTab:AddRightGroupbox("Chams", "wand")
    local WorldBox = VisualTab:AddRightGroupbox("World", "globe")
    local ObjectBox = VisualTab:AddLeftGroupbox("Object ESP", "cube")

    EspBox:AddToggle("espEnabled", {
        Text = "Enabled",
        Default = false,
        Callback = function(val) espSettings.enabled = val end
    })
    EspBox:AddToggle("espBox", {
        Text = "Box",
        Default = false,
        Callback = function(val) espSettings.box = val end
    }):AddColorPicker("boxColor", {
        Default = Color3.new(1,1,1),
        Title = "Box/Corner Color",
        Callback = function(val) espSettings.boxColor = val end
    })
    EspBox:AddDropdown("espBoxType", {
        Values = {"Default", "Corner"},
        Default = 1,
        Text = "Box Type",
        Callback = function(val) espSettings.boxtype = val end
    })
    EspBox:AddToggle("espName", {
        Text = "Name",
        Default = false,
        Callback = function(val) espSettings.name = val end
    }):AddColorPicker("nameColor", {
        Default = Color3.new(1,1,1),
        Title = "Name Color",
        Callback = function(val) espSettings.nameColor = val end
    })
    EspBox:AddToggle("espWeapon", {
        Text = "Weapon",
        Default = false,
        Callback = function(val) espSettings.weapon = val end
    }):AddColorPicker("weaponColor", {
        Default = Color3.new(1,1,1),
        Title = "Weapon Color",
        Callback = function(val) espSettings.weaponColor = val end
    })
    EspBox:AddToggle("espDistance", {
        Text = "Show Distance",
        Default = false,
        Callback = function(val) espSettings.distance = val end
    }):AddColorPicker("distanceColor", {
        Default = Color3.new(1,1,1),
        Title = "Distance Color",
        Callback = function(val) espSettings.distanceColor = val end
    })
    EspBox:AddSlider("espMaxDistance", {
        Text = "Max Distance",
        Default = 5000,
        Min = 1,
        Max = 10000,
        Rounding = 0,
        Callback = function(val) espSettings.maxDistance = val end
    })
    EspBox:AddToggle("espSleep", {
        Text = "Sleep Check",
        Default = false,
        Callback = function(val) espSettings.sleepcheck = val end
    })
    EspBox:AddToggle("espAICheck", {
        Text = "AI Check",
        Default = false,
        Callback = function(val) espSettings.aicheck = val end
    })

    ChamsBox:AddToggle("HandChams", {
        Text = "Hand Chams",
        Default = false,
        Callback = function(val) chamsSettings.hand = val end
    }):AddColorPicker("HandChamsColor", {
        Default = Color3.new(1, 1, 1),
        Title = "Hand Chams Color",
        Callback = function(val) chamsSettings.handColor = val end
    })
    ChamsBox:AddDropdown("HandChamsMat", {
        Values = {"ForceField", "Neon"},
        Default = "ForceField",
        Text = "Hand Material",
        Callback = function(val) chamsSettings.handMat = val end
    })
    ChamsBox:AddToggle("ItemChams", {
        Text = "Item Chams",
        Default = false,
        Callback = function(val) chamsSettings.item = val end
    }):AddColorPicker("ItemChamsColor", {
        Default = Color3.new(1, 1, 1),
        Title = "Item Chams Color",
        Callback = function(val) chamsSettings.itemColor = val end
    })
    ChamsBox:AddDropdown("ItemChamsMat", {
        Values = {"ForceField", "Neon"},
        Default = "ForceField",
        Text = "Item Material",
        Callback = function(val) chamsSettings.itemMat = val end
    })

    WorldBox:AddLabel("Map Visuals")
    WorldBox:AddToggle("NoGrass", {
        Text = "No Grass",
        Default = false,
        Callback = function(val)
            local terrain = workspace:FindFirstChildOfClass("Terrain")
            if sethiddenproperty and terrain then
                sethiddenproperty(terrain, "Decoration", not val)
            end
        end
    })
    WorldBox:AddToggle("NoLeaves", {
        Text = "No Leaves",
        Default = false,
        Callback = function(val)
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("BasePart") and obj.Name:match("Leaves$") then
                    if val then obj:Destroy() end
                end
            end
        end
    })
    WorldBox:AddToggle("Clouds", {
        Text = "Clouds",
        Default = true,
        Callback = function(val)
            local terrain = workspace:FindFirstChildOfClass("Terrain")
            local clouds = terrain and terrain:FindFirstChildOfClass("Clouds")
            if clouds then clouds.Enabled = val end
        end
    })
    WorldBox:AddToggle("Ambient", {
        Text = "Ambient",
        Default = false,
        Callback = function(val)
            local lighting = game:GetService("Lighting")
            lighting.Ambient = val and Color3.fromRGB(120,120,120) or Color3.fromRGB(0,0,0)
        end
    })
    WorldBox:AddToggle("AlwaysDay", {
        Text = "Always Day",
        Default = false,
        Callback = function(val)
            local lighting = game:GetService("Lighting")
            lighting.ClockTime = val and 6 or 14
        end
    })
    WorldBox:AddToggle("RemoveFog", {
        Text = "Remove Fog",
        Default = false,
        Callback = function(val)
            local lighting = game:GetService("Lighting")
            lighting.FogStart = val and 100000 or 0
            lighting.FogEnd = val and 100000 or 1000
        end
    })
    WorldBox:AddDropdown("SkyboxSelect", {
        Text = "Skybox",
        Values = {"Default"},
        Default = "Default",
        Callback = function(val)
            local lighting = game:GetService("Lighting")
            for _,v in pairs(lighting:GetChildren()) do
                if v:IsA("Sky") then v:Destroy() end
            end
            if val == "Default" then
                local sky = Instance.new("Sky")
                sky.Name = "WorldSkybox"
                sky.SkyboxBk = "rbxassetid://401664839"
                sky.SkyboxDn = "rbxassetid://401664862"
                sky.SkyboxFt = "rbxassetid://401664936"
                sky.SkyboxLf = "rbxassetid://401664881"
                sky.SkyboxRt = "rbxassetid://401664929"
                sky.SkyboxUp = "rbxassetid://401664883"
                sky.Parent = lighting
            end
        end
    })

    ObjectBox:AddToggle("objectEspDropped", {
        Text = "Dropped Item",
        Default = false,
        Callback = function(val) objectEspSettings.droppeditem = val end
    })
    ObjectBox:AddToggle("objectEspCorpse", {
        Text = "Corpse",
        Default = false,
        Callback = function(val) objectEspSettings.corpse = val end
    })
    ObjectBox:AddToggle("objectEspAtv", {
        Text = "ATV",
        Default = false,
        Callback = function(val) objectEspSettings.atv = val end
    })

    -- === CORE ===
    local camera = workspace.CurrentCamera
    local runservice = game:GetService("RunService")
    local coregui = game:GetService("CoreGui")
    local players = game:GetService("Players")
    local localplayer = players.LocalPlayer

    -- === PlayerTable Detection ===
    local PlayerTable
    do
        for _, v in pairs(getgc(true)) do
            if typeof(v) == "function" and islclosure(v) then
                local info = debug.getinfo(v)
                if info and tostring(info.name) == "updatePlayers" then
                    local ups = debug.getupvalues(v)
                    if type(ups[1]) == "table" and next(ups[1]) then
                        PlayerTable = ups[1]
                        break
                    end
                end
            end
        end
    end

    -- Получить weapon type с PlayerTable
    local function GetPlayerWeaponType(char)
        if not PlayerTable then return "hands" end
        for _, entry in pairs(PlayerTable) do
            if entry and entry.model == char then
                if entry.equippedItem and entry.equippedItem.type then
                    return tostring(entry.equippedItem.type)
                else
                    return "hands"
                end
            end
        end
        return "hands"
    end

    local ESPHolder = coregui:FindFirstChild("ESP_UI_FIX") or Instance.new("ScreenGui")
    ESPHolder.Name = "ESP_UI_FIX"
    ESPHolder.ResetOnSpawn = false
    ESPHolder.Parent = coregui
    local activeEsp = {}

    local function removeEspFor(char, esp)
        if esp then
            if esp.Box then esp.Box.Visible = false esp.Box:Remove() end
            if esp.Corners then for _, v in ipairs(esp.Corners) do v.Visible = false v:Remove() end end
            if esp.Name then esp.Name:Remove() end
            if esp.Weapon then esp.Weapon:Remove() end
            if esp.Distance then esp.Distance:Remove() end
        end
    end

    local function GetPlayerName(plrChar)
        local head = plrChar:FindFirstChild("Head")
        if head and head:FindFirstChild("Nametag") and head.Nametag:FindFirstChild("tag") then
            local tag = head.Nametag.tag
            if tag.Text ~= "" and tag.Text ~= nil then
                return tag.Text
            end
        end
        return "Player"
    end

    local function SleepCheck(plrChar)
        if not plrChar:FindFirstChild("AnimationController") then return false end
        for _,track in pairs(plrChar.AnimationController:GetPlayingAnimationTracks()) do
            if track.IsPlaying and track.Animation.AnimationId == "rbxassetid://13280887764" then
                return true
            end
        end
        return false
    end

    local function WorldToBox(char)
        local head = char:FindFirstChild("Head")
        local leftFoot = char:FindFirstChild("LeftFoot")
        local rightFoot = char:FindFirstChild("RightFoot")
        if not (head and leftFoot and rightFoot) then return end
        local topWorld = head.Position
        local bottomWorld = (leftFoot.Position.Y < rightFoot.Position.Y and leftFoot.Position or rightFoot.Position)
        local isSleeping = SleepCheck(char)
        if isSleeping then
            local torso = char:FindFirstChild("Torso")
            if torso then
                bottomWorld = torso.Position - Vector3.new(0, torso.Size.Y/2, 0)
            end
        end
        local top2d = camera:WorldToViewportPoint(topWorld)
        local bottom2d = camera:WorldToViewportPoint(bottomWorld)
        local scaleFactor = 15 / (top2d.Z * math.tan(math.rad(camera.FieldOfView * 0.5)) * 2) * 100
        local boxW = 2.4 * scaleFactor
        local boxH = 3 * scaleFactor
        if not (boxH > 1 and boxW > 1) then return end
        local left = top2d.X - boxW / 2
        local top = top2d.Y
        local right = top2d.X + boxW / 2
        local bottom = top + boxH
        return left, top, right, bottom, boxW, boxH, isSleeping
    end

    local function createEsp(char)
        if activeEsp[char] then return end
        local esp = {}
        esp.Box = Drawing.new("Square")
        esp.Box.Thickness = 1
        esp.Box.Color = espSettings.boxColor
        esp.Box.Filled = false
        esp.Box.Visible = false
        esp.Corners = {}
        for i = 1, 8 do
            local line = Drawing.new("Line")
            line.Thickness = 2
            line.Color = espSettings.boxColor
            line.Visible = false
            esp.Corners[i] = line
        end
        esp.Name = Drawing.new("Text")
        esp.Name.Size = 16
        esp.Name.Center = true
        esp.Name.Outline = true
        esp.Name.Visible = false
        esp.Weapon = Drawing.new("Text")
        esp.Weapon.Size = 14
        esp.Weapon.Center = true
        esp.Weapon.Outline = true
        esp.Weapon.Visible = false
        esp.Distance = Drawing.new("Text")
        esp.Distance.Size = 12
        esp.Distance.Center = true
        esp.Distance.Outline = true
        esp.Distance.Visible = false
        activeEsp[char] = esp

        esp._conn = runservice.RenderStepped:Connect(function()
            if not char or not char.Parent or not char:FindFirstChild("HumanoidRootPart") then
                esp._conn:Disconnect()
                removeEspFor(char, esp)
                activeEsp[char] = nil
                return
            end
            local hrp = char.HumanoidRootPart
            local dist = (camera.CFrame.Position - hrp.Position).Magnitude
            if not espSettings.enabled or dist > espSettings.maxDistance
            or (espSettings.aicheck and GetPlayerName(char) == "Shylou2644")
            or (espSettings.sleepcheck and SleepCheck(char)) then
                esp.Box.Visible = false
                for _, f in ipairs(esp.Corners) do f.Visible = false end
                esp.Name.Visible = false
                esp.Weapon.Visible = false
                esp.Distance.Visible = false
                return
            end
            local left, top, right, bottom, boxW, boxH = WorldToBox(char)
            if not left then return end
            local centerX = left + boxW / 2
            if espSettings.box then
                if espSettings.boxtype == "Corner" then
                    esp.Box.Visible = false
                    local len = boxW * 0.25
                    local lenY = boxH * 0.18
                    local c = esp.Corners
                    c[1].From = Vector2.new(left, top)
                    c[1].To = Vector2.new(left + len, top)
                    c[2].From = Vector2.new(left, top)
                    c[2].To = Vector2.new(left, top + lenY)
                    c[3].From = Vector2.new(right, top)
                    c[3].To = Vector2.new(right - len, top)
                    c[4].From = Vector2.new(right, top)
                    c[4].To = Vector2.new(right, top + lenY)
                    c[5].From = Vector2.new(left, bottom)
                    c[5].To = Vector2.new(left + len, bottom)
                    c[6].From = Vector2.new(left, bottom)
                    c[6].To = Vector2.new(left, bottom - lenY)
                    c[7].From = Vector2.new(right, bottom)
                    c[7].To = Vector2.new(right - len, bottom)
                    c[8].From = Vector2.new(right, bottom)
                    c[8].To = Vector2.new(right, bottom - lenY)
                    for i = 1, 8 do
                        c[i].Color = espSettings.boxColor
                        c[i].Visible = true
                    end
                else
                    for _, f in ipairs(esp.Corners) do f.Visible = false end
                    esp.Box.Position = Vector2.new(left, top)
                    esp.Box.Size = Vector2.new(boxW, boxH)
                    esp.Box.Visible = true
                    esp.Box.Color = espSettings.boxColor
                end
            else
                esp.Box.Visible = false
                for _, f in ipairs(esp.Corners) do f.Visible = false end
            end
            local spacing = 1
            local nameY = top - esp.Name.Size - spacing
            local weapY = bottom + spacing
            local distY = weapY + esp.Weapon.Size + spacing
            if espSettings.name then
                esp.Name.Visible = true
                local realName = GetPlayerName(char)
                esp.Name.Text = realName == "Shylou2644" and not espSettings.aicheck and "AI" or realName
                esp.Name.Position = Vector2.new(centerX, nameY)
                esp.Name.Color = espSettings.nameColor
            else
                esp.Name.Visible = false
            end
            if espSettings.weapon then
                esp.Weapon.Visible = true
                local weap = GetPlayerWeaponType(char)
                esp.Weapon.Text = weap or "hands"
                esp.Weapon.Position = Vector2.new(centerX, weapY)
                esp.Weapon.Color = espSettings.weaponColor
            else
                esp.Weapon.Visible = false
            end
            if espSettings.distance then
                esp.Distance.Visible = true
                esp.Distance.Text = string.format("%dm", math.floor(dist))
                esp.Distance.Position = Vector2.new(centerX, espSettings.weapon and distY or weapY)
                esp.Distance.Color = espSettings.distanceColor
            else
                esp.Distance.Visible = false
            end
        end)
    end

    local function UpdateAllEsps()
        for char, esp in pairs(activeEsp) do
            if not char or not char.Parent or not char:FindFirstChild("HumanoidRootPart") then
                removeEspFor(char, esp)
                activeEsp[char] = nil
            end
        end
        for _, v in pairs(workspace:GetChildren()) do
            if v:FindFirstChild("HumanoidRootPart") and v ~= localplayer.Character then
                if not activeEsp[v] then
                    createEsp(v)
                end
            end
        end
    end

    local Drawing = Drawing or getgenv().Drawing
    local objectEspDrawings = {dropped = {}, corpse = {}, atv = {}}

    local function updateDroppedItemEsp()
        for _, d in pairs(objectEspDrawings.dropped) do d:Remove() end
        table.clear(objectEspDrawings.dropped)
        if not objectEspSettings.droppeditem then return end
        for _, obj in ipairs(workspace:GetChildren()) do
            if obj.Name == "DroppedItem" or (obj:IsA("Model") and obj:FindFirstChild("DroppedItem")) then
                local pos = obj.Position or (obj.PrimaryPart and obj.PrimaryPart.Position) or (obj:FindFirstChild("DroppedItem") and obj.DroppedItem.Position)
                if pos then
                    local text = Drawing.new("Text")
                    local screen, onScreen = camera:WorldToViewportPoint(pos)
                    text.Visible = onScreen
                    text.Position = Vector2.new(screen.X, screen.Y)
                    text.Text = "Dropped"
                    text.Size = 14
                    text.Color = Color3.fromRGB(204, 153, 255)
                    text.Outline = true
                    text.OutlineColor = Color3.new(0,0,0)
                    objectEspDrawings.dropped[obj] = text
                end
            end
        end
    end

    local function updateCorpseEsp()
        for _, d in pairs(objectEspDrawings.corpse) do d:Remove() end
        table.clear(objectEspDrawings.corpse)
        if not objectEspSettings.corpse then return end
        for _, obj in ipairs(workspace:GetChildren()) do
            if obj.Name:lower():find("corpse") or (obj:IsA("Model") and (obj.PrimaryPart and obj.PrimaryPart.Name:lower():find("corpse"))) then
                local primary = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
                if primary then
                    local text = Drawing.new("Text")
                    local screen, onScreen = camera:WorldToViewportPoint(primary.Position)
                    text.Visible = onScreen
                    local dist = (camera.CFrame.Position - primary.Position).Magnitude
                    text.Position = Vector2.new(screen.X, screen.Y)
                    text.Text = string.format("Corpse [%dm]", math.floor(dist))
                    text.Size = 14
                    text.Color = Color3.fromRGB(255, 0, 0)
                    text.Outline = true
                    text.OutlineColor = Color3.new(0,0,0)
                    objectEspDrawings.corpse[obj] = text
                end
            end
        end
    end

    local function updateAtvEsp()
        for _, d in pairs(objectEspDrawings.atv) do d:Remove() end
        table.clear(objectEspDrawings.atv)
        if not objectEspSettings.atv then return end
        for _, obj in ipairs(workspace:GetChildren()) do
            if obj:FindFirstChild("Seat") and obj:FindFirstChild("Plastics") then
                local primary = obj.PrimaryPart or obj:FindFirstChild("Plastics") or obj:FindFirstChildWhichIsA("BasePart")
                if primary then
                    local text = Drawing.new("Text")
                    local screen, onScreen = camera:WorldToViewportPoint(primary.Position)
                    text.Visible = onScreen
                    local dist = (camera.CFrame.Position - primary.Position).Magnitude
                    text.Position = Vector2.new(screen.X, screen.Y)
                    text.Text = string.format("ATV [%dm]", math.floor(dist))
                    text.Size = 14
                    text.Color = Color3.fromRGB(61, 255, 200)
                    text.Outline = true
                    text.OutlineColor = Color3.new(0,0,0)
                    objectEspDrawings.atv[obj] = text
                end
            end
        end
    end

    runservice.RenderStepped:Connect(function()
        UpdateAllEsps()
        updateDroppedItemEsp()
        updateCorpseEsp()
        updateAtvEsp()
    end)

    getgenv().TridentLibrary = getgenv().TridentLibrary or {}
    local Library = getgenv().TridentLibrary
    if Library.OnUnload then
        Library:OnUnload(function()
            for _, tbl in pairs(objectEspDrawings) do
                for _, d in pairs(tbl) do d:Remove() end
            end
            for char, esp in pairs(activeEsp) do
                removeEspFor(char, esp)
            end
        end)
    end
end
